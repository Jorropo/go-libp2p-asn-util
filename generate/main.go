package main

import (
	"encoding/binary"
	"encoding/csv"
	"errors"
	"fmt"
	"io"
	"math"
	"math/bits"
	"net"
	"os"
	"sort"

	u "github.com/ipfs/go-ipfs-util"
)

const (
	pkgName        = "asnutil"
	ipv6OutputFile = "ipv6_asn_map.go"
	ipv6MapName    = "ipv6CidrToAsnMap"
)

type asn struct {
	prefix uint64
	asn    string
}

func main() {
	// file with the ASN mappings for IPv6 CIDRs.
	// See ipv6_asn.tsv
	ipv6File := os.Getenv("ASN_IPV6_FILE")

	if len(ipv6File) == 0 {
		panic(errors.New("environment vars must be provided"))
	}

	ipv6CidrToAsnMap := readMappingFile(ipv6File)
	f, err := os.Create(ipv6OutputFile)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	writeMappingToFile(f, ipv6CidrToAsnMap, ipv6MapName)
}

func writeMappingToFile(f *os.File, m []asn, mapName string) {
	printf := func(s string, args ...interface{}) {
		_, err := fmt.Fprintf(f, s, args...)
		if err != nil {
			panic(err)
		}
	}
	printf("package %s\n\n", pkgName)
	printf("// Code generated by generate/main.go DO NOT EDIT\n")
	printf("var %s = []asn {", mapName)
	for _, v := range m {
		printf("\n\t{%#v, %#v},", v.prefix, v.asn)
	}
	printf("\n}")
}

func readMappingFile(path string) (m []asn) {
	f, err := os.Open(path)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	r := csv.NewReader(f)
	r.Comma = '\t'
	for {
		record, err := r.Read()
		// Stop at EOF.
		if err == io.EOF {
			return m
		}

		startIP := record[0]
		endIP := record[1]
		asnName := record[2]
		if asnName == "0" {
			continue
		}

		s := net.ParseIP(startIP)
		e := net.ParseIP(endIP)
		if s.To16() == nil || e.To16() == nil {
			panic(errors.New("IP should be v6"))
		}

		prefixLen := zeroPrefixLen(u.XOR(s.To16(), e.To16()))

		if prefixLen > 56 {
			prefixLen = 56
			// UGH
		}
		prefix := (binary.BigEndian.Uint64(s.To16()) & (math.MaxUint64 << (64 - prefixLen))) | uint64(uint8(prefixLen))
		m = append(m, asn{
			asn:    asnName,
			prefix: prefix,
		})
	}
	sort.Slice(m, func(i, j int) bool {
		return m[i].prefix&^0xFF < m[j].prefix&^0xFF
	})
	for i := range m[1:] {
		if m[i-1].prefix&^0xFF == m[i].prefix&^0xFF {
			panic("conflicting ASN prefix detected")
		}
	}

	return m
}

func zeroPrefixLen(id []byte) int {
	for i, b := range id {
		if b != 0 {
			return i*8 + bits.LeadingZeros8(uint8(b))
		}
	}
	return len(id) * 8
}
